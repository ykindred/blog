---
title: 竞赛算法(7) 数据结构
published: 2025-11-29
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---

## 树状数组
Fenwick tree 或者叫 Binary Indexed Tree, 功能类似于线段树, 只不过在差分操作的辅助下可以将空间压到$O(n)$, 并且代码简短, 常数小. 树状数组的索引通常从1开始. 树状数组只能维护满足结合律且可差分的数据和运算.

树状数组维护的运算必须满足群的性质.

树状数组和线段树作用的两个区别:
1. 如果需要区间查询操作, 树状数组只能维护可差分信息(这一点可以通过维护两个树状数组来解决, 但时间复杂度升高)
2. 树状数组修改操作使用的运算必须与维护信息的运算相同(或者说, 构成群结构), 而线段树不需要.(本质区别)

:::note[树状数组的性质]
以下以`c[i]`代指`i`的管辖区间.
1. 对于任意索引`x`, `c[x]`为`[x - lowbit(x) + 1, x]`;
2. 对于任意`x <= y`, 要么`c[x]`和`c[y]`不相交, 要么`c[x]`包含于`c[y]`.
3. 任意`c[x]`包含于`c[x + lowbit(x)]`, 并且对于`(x, x + lowbit(x))`之间任意索引`y`, 都有`c[y]`与`c[x]`不相交.
:::

在了解这些性质之后, 我们可以得到树状数组的单点修改和区间查询操作.
:::note[树状数组的区间查询操作]
以下`f[l, r]`代表目标函数从`l`到`r`的区间和.
1. 要查询`f[l, r]`时, 只需查询`f[1, r] - f[1, l - 1]`;
2. 要查询`f[1, r]`时: 初始令`i = r`, 然后每次让`i -= lowbit(i)`直到`i == 0`. 叠加所有的`f[c[i]]`即可.
:::

:::note[树状数组的单点修改操作]
假如要修改`f[x]`.
1. 修改`f[c[x]]`.
2. 令`x = x + lowbit(x)`, 若`x > n`说明修改完毕, 否则重复步骤1.
:::

建树时对每个节点进行单点修改操作即可.

手写模板无论如何都无法避免`n`传参的问题, 建议直接使用以下的封装模板, 代码不长.

```cpp
struct FwTree {
    int n;
    vector<ll> c;
    inline int lowbit(int x) {
        return x & -x;
    }

    FwTree(int n) : n(n + 5), c(n + 5, 0) {

    }

    FwTree(const vector<ll>& arr) : FwTree(arr.size()) {
        for (int i = 1; i <= n; i++) {
            c[i] = arr[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int fa = i + lowbit(i);
            if (fa <= n) {
                c[fa] += c[i];
            }
        }
    }

    ll sum(int x) {
        ll ret = 0;
        for (++x; x > 0; x -= lowbit(x)) {
            ret += c[x];
        }
        return ret;
    }

    ll sum(int l, int r) {
        if (l > r) return 0;
        return sum(r) - sum(l - 1);
    }

    void add(int x, ll val) {
        for (++x; x <= n; x += lowbit(x)) {
            c[x] += val; 
        }
    }
};
```

这个实现是允许查下标`0`的, 因为所有的`x`都被映射到了`++x`处. (如果理不清各种下标之间的关系, 就不要理了, 树状数组的功能是没问题的).

### 权值树状数组
其实就是把cnt数组存在树状数组里, 起了个高大上的名字.

这时其实我们就能查询大小在区间[L, R]里的数字个数了.

**权值树状数组的核心用法:** 查询索引在`i`左边/右边的数字中, 大小在某一区间内的数字个数. 也就是说, 假如数组是`a[1], a[2], ..., a[n]`, 权值树状数组可以在$O(n\log n)$内建树, 在$O(\log n)$内查询`i < q`/`i > p`且`a[i] >= L && a[i] <= R`的`a[i]`数量.

有人就要问了, 既然需要$O(n\log n)$的时间建树, 那我为什么不直接暴力$O(n)$查找呢? 这是因为很多题目的查询是离线的, 这时我们可以把所有需要查询的`i < q`的问题按`q`的大小排好序, 这样建树的时候只需要从前往后建, 建到`q_j`的时候查询`q_j`处的问题, 只需要一次建树就能解决. 分摊复杂度$O(\log n)$.

[SPOJ K-query](https://www.spoj.com/problems/KQUERY/)(说白了就是查询[L, R]处满足>K的数字个数)


### 区间加, 区间和
显然, 树状数组可以在$O(\log n)$的时间内实现单点修改和前缀和查询. 而我们发现如果用这个性质来维护差分数组的话, 单点修改其实就对应了原数组的区间修改, 前缀和就对应了原数组的单点值. 所以用树状数组来维护原数组的差分可以实现区间修改, 单点查询.




## 线段树
