---
title: 竞赛算法(7) 数据结构
published: 2025-11-29
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---

## 树状数组
Fenwick tree 或者叫 Binary Indexed Tree, 功能类似于线段树, 只不过在差分操作的辅助下可以将空间压到$O(n)$, 并且代码简短, 常数小. 树状数组的索引通常从1开始. 树状数组只能维护满足结合律且可差分的数据和运算.

树状数组和线段树作用的两个区别:
1. 如果需要区间查询操作, 树状数组只能维护可差分信息(这一点可以通过维护两个树状数组来解决, 但时间复杂度升高)
2. 树状数组修改操作使用的运算必须与维护信息的运算相同(或者说, 构成群结构), 而线段树不需要.(本质区别)

:::note[树状数组的性质]
以下以`c[i]`代指`i`的管辖区间.
1. 对于任意索引`x`, `c[x]`为`[x - lowbit(x) + 1, x]`;
2. 对于任意`x <= y`, 要么`c[x]`和`c[y]`不相交, 要么`c[x]`包含于`c[y]`.
3. 任意`c[x]`包含于`c[x + lowbit(x)]`, 并且对于`(x, x + lowbit(x))`之间任意索引`y`, 都有`c[y]`与`c[x]`不相交.
:::

在了解这些性质之后, 我们可以得到树状数组的单点修改和区间查询操作.
:::note[树状数组的区间查询操作]
以下`f[l, r]`代表目标函数从`l`到`r`的区间和.
1. 要查询`f[l, r]`时, 只需查询`f[1, r] - f[1, l - 1]`;
2. 要查询`f[1, r]`时: 初始令`i = r`, 然后每次让`i -= lowbit(i)`直到`i == 0`. 叠加所有的`f[c[i]]`即可.
:::

:::note[树状数组的单点修改操作]
假如要修改`f[x]`.
1. 修改`f[c[x]]`.
2. 令`x = x + lowbit(x)`, 若`x > n`说明修改完毕, 否则重复步骤1.
:::

建树时对每个节点进行单点修改操作即可.

```cpp
#define lowbit(x) ((x) & (-x))

int c[N];

int cal(int x, int y) {
    return x + y;   // 运算逻辑
}

int dif(int k, int y) {
    // 若 cal(x, y) = k, 则dif(k, y) = x
    return k - y;
}

#define IE 0        // 零元

int ask(int x) {
    int sum = IE;
    for (int i = x; i > 0; i -= lowbit(i)) {
        sum = cal(sum, c[i]);
    }
    return sum;
}

int query(int l, int r) {
    // l >= 1
    return dif(ask(r), ask(l - 1));
}

void modify(int x, int val, int n) {
    // 将 x 位置的值增加(cal) val, 数组大小为 n
    for (int i = x; i <= n; i += lowbit(i)) {
        c[i] = cal(c[i], val);
    }
}

void build(int n, const vector<int>& arr) {
    // 传入arr应为 1-based
    for (int i = 1; i <= n; i++) {
        c[i] = IE;
    }
    for (int i = 1; i <= n; i++) {
        modify(i, arr[i], n);
    }
}
```


### 区间加, 区间和
通过


## 线段树
