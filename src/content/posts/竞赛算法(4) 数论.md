---
title: 竞赛算法(4) 数论
published: 2025-11-24
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---
## 数论基础
### 整除
具有如下基础性质:
1. $a | b$则$-a | b$, $a | -b$
2. $a | b$, $b | c$则$a | c$
3. $a | b$, $a | c$则$a | xb + yc$
4. $a | b$, $b | a$则$b = a$或$b = -a$
5. $a | b$则$ma | mb(m\ne0)$.
6. $a | b$, $b\ne0$则$|a| \le |b|$
7. $a | b$则$a | b\% a$

有上述性质可知整除是整数集上的偏序关系. 若a整除b, 则称a为b的约数, b为a的倍数.

0, 1, -1, b, -b称为平凡约数, 其他约数称为真约数.

若$b\ne0$, 当$d$遍历$b$的全体约数时, $b/d$也遍历$b$的全体约数.

### 带余除法
$b = (b / a)a + b \% a$.

相邻的 a 个整数被正整数 a 除后, 恰好取到上述 a 个余数. 特别地, 一定有且仅有一个数被 a 整除.

### gcd与lcm
gcd有如下性质:
1. `gcd(a, b) = gcd(-a, b)`, 正负不影响结果
2. `gcd(a, b) = gcd(b, a)`, 可交换
3. `gcd(a, 0) = gcd(a, a) = abs(a)`
4. `gcd(bq + r, b) = gcd(r, b)`
5. `gcd(a, b, c) = gcd(gcd(a, b), c)`, 可结合
6. `gcd(a, b, c...) * m = gcd(ma, mb, mc...)`
7. `gcd(a^n, b^n) = gcd(a, b)^n`
8. 若`gcd(a, b, c...) = d`, 则`gcd(a / d, b / d, c / d...) = 1`
9. 若`a | bc`, `a, b`互质, 则`a | c`.
10. 若`a | c`, `b | c`, `a, b`互质, 则`ab | c`.
11. 若`a, b`互质, 则`gcd(a, bc) = gcd(a, c)`
12. 若`A, B`数组组间两两互质, 即任意`a, b`互质, 则`mul(A), mul(B)`互质.
13. 若互质的`n`个数相乘等于某个数`v`的`m`次方, 则这`n`个数每个都是完全`m`次方数.

lcm有如下性质:
1. 同gcd
2. 同gcd
3. 同gcd
4. 若`a | b`, 则`lcm(a, b) = b`
5. 可结合
6. 同gcd
7. 若数组`A`每个数`a`都有`a | m`, 则`lcm(A) | m`.
8. `lcm(a, b, c)lcm(ab, bc, ca) = lcm(a, b)lcm(b, c)lcm(a, c)`
9. `lcm(a^n, b^n) = lcm(a, b)^n`

有一些奇怪的等式:
1. `gcd(a, b)lcm(a, b) = ab`
2. `gcd(ab, bc, ca)lcm(a, b, c) = abc`
3. `gcd(a, b, c)gcd(a, b, c) / gcd(a, b)gcd(a, c)gcd(b, c) = lcm[a, b, c]lcm[a, b, c] / lcm(a, b)lcm(a, c)lcm(b, c)`

### 质数
所有大于3的素数都可以表示为`6n + 1`或`6n + 5`的形式.

### 算术基本定理
算术基本引理: 若`p`为素数, `p | xy`, 则要么`p | x`, 要么`p | y`.
算术基本定理/唯一分解定理: `a`可被唯一的素数数组`P`表示, `a = mul(P)`
这两个定理等价.

### 同余
若`m | (a - b)`称`a, b`模`m`同余, 记作$a\equiv b\pmod m$
同余是一种等价关系.
同余的性质:
1. 自反, 对称, 传递
2. 线性运算(加减乘)
3. 若两个整系数多项式的所有系数模`m`同余, 则这两个多项式模`m`同余意义下等价. (对于任意`s, t`模`m`同余, `f(s)`与`g(t)`模`m`同余)
4. `a, b`模`m`同余, 则`ak`, `bk`模`mk`同余. 若`k`整除`a, b, m`, 则反过来也一样.
5. 若`d | m`, `a, b`模`m`同余, 则`a, b`模`d`同余.
6. 若`a, b`模`m`同余, 则`gcd(a, m) = gcd(b, m)`.
7. 若`a, b`模`m`同余, `d | m`且`d | a`, 则`d | b`.

### 同余类与剩余系


## 模运算算法
### 模运算环
```cpp
namespace numth {
    inline ll norm(ll x, ll mod) { ll tmp = x % mod; return (tmp < 0) ? (tmp + mod) : tmp; }
    inline ll mul(ll a, ll b, ll mod) { auto tmp = (i128)a * b % mod; return (tmp < 0) ? (tmp + mod) : tmp; }
    inline ll add(ll a, ll b, ll mod) { return norm(a + b, mod); }
    inline ll sub(ll a, ll b, ll mod) { return norm(a - b, mod); }
    inline ll pow(ll a, ll b, ll mod) { 
        ll ret = 1;
        a = norm(a, mod);
        for (; b; b >>= 1, a = mul(a, a, mod)) if (b & 1) ret = mul(ret, a, mod); 
        return ret;
    }
    inline ll inv(ll a, ll mod_prime) { return pow(a, mod_prime - 2, mod_prime); }
}
```
在模数为质数的情况下, 模运算构成一个环.
`norm`: 模. 模运算的结果总是在`[0, mod)`之间.

### 模整数类
代码比模运算环更长, 但健壮性更好(支持合数模数), 且速度更快.
静态u32(最快):
```cpp
template <int MOD> 
struct modint {
    static constexpr u32 umod = u32(MOD);
    static constexpr int mod = MOD;
    static constexpr int get_mod() { return mod; }
    static_assert(umod < u32(1) << 31);
    u32 val;

    // fast construction of raw modint
    static modint raw(u32 v) {
        modint x;
        x.val = v;
        return x;
    }

    // constructors
    constexpr modint() : val(0) {}
    constexpr modint(u32 x) : val(x % umod) {}
    constexpr modint(u64 x) : val(x % umod) {}
    constexpr modint(u128 x) : val(x % umod) {}
    constexpr modint(int x) : val((x %= mod) < 0 ? x + mod : x) {};
    constexpr modint(ll x) : val((x %= mod) < 0 ? x + mod : x) {};
    constexpr modint(i128 x) : val((x %= mod) < 0 ? x + mod : x) {};

    // operators
    bool operator<(const modint &other) const { return val < other.val; }
    modint &operator+=(const modint &p) {
        if ((val += p.val) >= umod) {
            val -= umod;
        }
        return *this;
    }
    modint &operator-=(const modint &p) {
        if ((val += umod - p.val) >= umod) {
            val -= umod;
        }
        return *this;
    }
    modint &operator*=(const modint &p) {
        val = u64(val) * p.val % umod;
        return *this;
    }
    modint &operator/=(const modint &p) {
        // O(log mod)
        assert(p.val != 0 && "modint div zero");
        *this *= p.inv();
        return *this;
    }
    modint operator-() const { return modint::raw(val ? mod - val : u32(0)); }
    modint operator+(const modint &p) const { return modint(*this) += p; }
    modint operator-(const modint &p) const { return modint(*this) -= p; }
    modint operator*(const modint &p) const { return modint(*this) *= p; }
    modint operator/(const modint &p) const { return modint(*this) /= p; }  // O(log mod)
    bool operator==(const modint &p) const { return val == p.val; }
    bool operator!=(const modint &p) const { return val != p.val; }
    
    // quick power of O(log n)
    modint qkpow(ll n) const {
        if (n < 0) return inv().qkpow(-n);
        modint ret(1), mul(val);
        while (n > 0) {
            if (n & 1) ret *= mul;
            mul *= mul;
            n >>= 1;
        }
        return ret;
    }

    // inv by extgcd of O(log mod)
    modint inv() const {
        // no inv for zero, no inv for non-coprime
        assert(val != 0 && "modint inv zero");
        assert((gcd((int)val, mod) == 1) && "modint inv not coprime");

        int a = val, b = mod, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b), swap(u -= t * v, v);
        }
        return modint(u);
    }

    // stream IO
    friend std::istream &operator>>(std::istream &is, modint &a) {
        ll t;
        is >> t;
        a = modint(t);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const modint &a) {
        return os << a.val;
    }
};
using mint107 = modint<1000000007>;
using mint998 = modint<998244353>;
```
`O2`有自动`Barrett`优化, 而且不涉及`i128`, 常数非常小. 且支持所有常见运算. 无依赖.

### Barrett算法
```cpp
struct Barrett {
    u32 m;
    u64 im;
    explicit Barrett(u32 m = 1) : m(m), im(u64(-1) / m + 1) {}
    u32 umod() const { return m; }
    u32 modulo(u64 z) {
        if (m == 1) return 0;
        u64 x = (u64)(((unsigned __int128)(z)*im) >> 64);
        u64 y = x * m;
        return (z - y + (z < y ? m : 0));
    }
    u64 floor(u64 z) {
        if (m == 1) return z;
        u64 x = (u64)(((unsigned __int128)(z)*im) >> 64);
        u64 y = x * m;
        return (z < y ? x - 1 : x);
    }
    pair<u64, u32> divmod(u64 z) {
        if (m == 1) return {z, 0};
        u64 x = (u64)(((unsigned __int128)(z)*im) >> 64);
        u64 y = x * m;
        if (z < y) return {x - 1, z - y + m};
        return {x, z - y};
    }
    u32 mul(u32 a, u32 b) { return modulo(u64(a) * b); }
};
```

### 模整数类(动态)
基于手写`Barrett`算法. 支持u32范围内的模数(更大的模数需要手写`Barrett64`和`Dynamic_modint64`)
```cpp
template <int id>
struct Dynamic_Modint {
    static constexpr bool is_modint = true;
    using mint = Dynamic_Modint;
    u32 val;
    static Barrett bt;
    static u32 umod() { return bt.umod(); }

    static int get_mod() { return (int)(bt.umod()); }
    static void set_mod(int m) {
        assert(1 <= m);
        bt = Barrett(m);
    }

    static Dynamic_Modint raw(u32 v) {
        Dynamic_Modint x;
        x.val = v;
        return x;
    }
    Dynamic_Modint() : val(0) {}
    Dynamic_Modint(u32 x) : val(bt.modulo(x)) {}
    Dynamic_Modint(u64 x) : val(bt.modulo(x)) {}
    Dynamic_Modint(int x) : val((x %= get_mod()) < 0 ? x + get_mod() : x) {}
    Dynamic_Modint(ll x) : val((x %= get_mod()) < 0 ? x + get_mod() : x) {}
    Dynamic_Modint(i128 x) : val((x %= get_mod()) < 0 ? x + get_mod() : x){};

    mint& operator+=(const mint& rhs) {
        val = (val += rhs.val) < umod() ? val : val - umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        val = (val += umod() - rhs.val) < umod() ? val : val - umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        val = bt.mul(val, rhs.val);
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }
    mint operator-() const { return mint() - *this; }
    mint pow(ll n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x, n >>= 1;
        }
        return r;
    }
    mint inv() const {
        int x = val, mod = get_mod();
        int a = x, b = mod, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b), swap(u -= t * v, v);
        }
        if (u < 0) u += mod;
        return u;
    }

    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs; }
    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs; }
    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs; }
    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs; }
    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs.val == rhs.val; }
    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs.val != rhs.val; }
};

using dmint = Dynamic_Modint<-1>;
template <int id>
Barrett Dynamic_Modint<id>::bt;
```


## 数论函数
正整数到整数(在广义数论中可以是复数)的函数. 可以被看作一个数列.

### 积性函数
1. $f(1) = 1$.
2. 对于互质的$x$, $y$, 有$f(xy) = f(x)f(y)$.

:::note[完全积性函数]
1. $f(1) = 1$.
2. 对于任意的$x$与$y$, 有$f(xy) = f(x)f(y)$.
:::

:::note[积性函数的性质]
若$f(x), g(x)$都是积性函数:
1. $f(x^p)$也是积性函数.
2. $f^p(x)$也是积性函数.
3. $f(x)g(x)$也是积性函数.
4. $\displaystyle \sum _{d|x}f(d)g(\frac{x}{d})$也是积性函数.
5. 容易注意到正整数在唯一分解后, 积性函数等于其每一个质因数幂次的函数值相乘, 完全积性函数还等于其每一个质因数的函数值相乘.
:::

:::note[常见的积性函数]
1. 单位函数$\epsilon (n) = [n = 1].$即$n = 1$的指示函数. 为完全积性函数.
2. 恒等函数$id_k(n) = n^k, id(n) = n$. 完全积性.
3. 常数函数$1(n) = 1$. 完全积性.
4. 除数函数$\displaystyle \sigma _k(n) = \sum _{d|n}d^k$. 其中$\sigma _0(n)$常记作$d(n)$或$\tau(n)$, $\sigma_1(n)$常记作$\sigma(n)$.
5. 欧拉函数$\varphi(n) = \displaystyle\sum_{i = 1}^{n}[gcd(i, n) = 1]$.
6. 莫比乌斯函数$\mu (n)$. $n$为$1$时值为$1$, $n$为完全平方数的整数倍时值为$0$, 其他时候值为$(-1)^k$, 其中$k$为$n$的不相等质因子个数.
:::


## 欧拉函数
一种数论函数, 记作$\varphi(n)$, 是一种积性函数, 其含义为小于等于n的正整数中与n互质的数的个数.

:::note[欧拉函数的性质]
1. 欧拉函数是积性函数. 特别地, 当$n$为奇数时, $\varphi(2n) = \varphi(n)$.
2. $n = \displaystyle\sum_{d|n}\varphi(d)$. 即恒等函数$id$是常数函数$1$和欧拉函数$\varphi$的狄利克雷卷积.
3. 若$n = p^k$, 则$\varphi(n) = p^k - p^{k - 1}$.
4. $\varphi(n)$等于$n$除以所有不同的质因数, 再乘以所有不同质因数-1的结果.
:::

## 莫比乌斯函数
一种数论函数, 记作$\mu(n)$:
1. $n = 1$时$\mu(n) = 1$.
2. $n$的质因数分解形如$p_1p_2p_3\cdots p_k$, 其中$p_i$之间互不相等时, $\mu(n) = (-1)^k$.
3. 其他时候, $\mu(n) = 0$.

莫比乌斯函数是一种积性函数.

莫比乌斯函数可以使用质因数分解在$O(\sqrt{n})$时间内求出. 也可使用线性筛在$O(n)$时间内预处理出$1\sim n$内所有的莫比乌斯函数值.

## 欧拉筛
一种$O(n)$的筛法, 也叫线性筛.

:::[欧拉筛处理质数的过程]
1. 维护质数表`primes`(要求支持$O(1)$尾插), 最小质因数表`minp`.
2. 循环, 到`i`时(先判后筛):
   1. 判: 若`minp[i] == 0`, 说明没被筛过, 为质数. `minp[i] = i`, `primes`尾插`i`.
   2. 筛: 遍历所有小于等于`minp[i]`的质数`pj`. 我们考虑`i * pj`, 可以知道`pj`一定是`i * pj`的最小质因数(由唯一分解定理). 于是记录`minp[i * pj] = pj`, 表示`i * pj`已经被筛过.
:::

这个过程中, `minp`可以换成一个`bool`数组`vis`以节省空间, 这样的话筛的时候条件改为"从小到大遍历所有`i % pj != 0`的质数和第一个`i % pj == 0`的质数". 常数时间接近, 空间节省, 但缺少了副产物`minp`表.

欧拉筛用于预处理$\varphi(n)$, $\mu(n)$, $d(n)$, $\sigma(n)$等特殊积性函数时, 利用其特殊性质可以避开处理一般积性函数时较差的时空复杂度.

```cpp
using i8 = int8_t;
using ll = long long;
// 全局
int minp[N];        // minp[i]反映i的最小质因数
/*
int phi[N], d[N];
i8 mu[N];
int times[N];       // 求d用, 表示最小质因子的次数.

ll sigma[N];
int g[N];           // 求sigma用, 表示最小质因子的幂次贡献的约数和.
*/

// 局部
vector<int> primes; // 质数表, primes[0] = 2
auto euler = [&](int n) -> void {
    primes.clear();
    memset(minp, 0, sizeof(int) * (n + 3));
    /*
    memset(phi, 0, sizeof(int) * (n + 3));
    memset ... 以下省略

    phi[1] = mu[1] = d[1] = sigma[1] = 1;
    */
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            primes.push_back(i);
            minp[i] = i;
            /*
            phi[i] = i - 1;

            mu[i] = -1;

            d[i] = 2;
            times[i] = 1;

            sigma[i] = i + 1;
            g[i] = i + 1;
            */
        }
        for (const auto& pj : primes) {
            if (pj > minp[i] || pj > n / i) break;
            /*
            if (pj == minp[i]) {
                phi[i * pj] = phi[i] * pj;

                mu[i * pj] = 0;

                d[i * pj] = d[i] / (times[i] + 1) * (times[i] + 2);
                times[i * pj] = times[i] + 1;

                g[i * pj] = g[i] * pj + 1;
                sigma[i * pj] = sigma[i] / g[i] * g[i * pj];
            }
            else {
                phi[i * pj] = phi[i] * (pj - 1);

                mu[i * pj] = -mu[i];

                d[i * pj] = d[i] * 2;
                times[i * pj] = 1;

                sigma[i * pj] = sigma[i] * sigma[pj];
                g[i * pj] = pj + 1;
            }
            */
            minp[i * pj] = pj;
        }
    }
};

// 判定质数
auto isprime = [&](int x) -> bool {
    return x == minp[x];
};
```

### 欧拉筛求一般积性函数
若可以在关于$k$的低次多项式时间(在算法竞赛中, 可以忽略"低次", 因为$k$可以看作常数)内得到积性函数$f$在$p^k$处的值(其中$p$为质数), 便可在$O(n)$内使用线性筛预处理出$1\sim n$范围内所有的$f(n)$值.

:::note[欧拉筛预处理积性函数的过程]
1. 维护质数表`primes`($O(1)$尾插). `<int>minp`或`<bool>vis`用于标记. `low`用于记录`i`的最小质因子的完整幂. `f`用于储存答案. 定义函数`getf(int p, int pk)`用于快速求$f(p^k)$. 初始化`f[1] = 1, low[1] = 1`.
2. 循环, 到`i`时(先判后筛):
   1. 判: 若为质数, 更新4项(包括`primes`).
   2. 筛, 其实就是3个分支, (注意`pj > n / i`时要提前`break`):
      1. `pj < minp[i]`, 更新3项.
      2. `pj == minp[i]`, 更新`low[tgt]`和`minp[tgt]`, 判断, 最后`break`:
         1. `i == low[i]`, 说明`i`是质数整幂, 调用`getf`;
         2. `i != low[i]`, 直接计算`f`.
:::

```cpp
// 全局
int minp[N], low[N];
ll f[N];

// 局部
vector<int> primes;
auto euler = [&](int n) -> void {
    primes.clear();
    memset(minp, 0, sizeof(int) * (n + 3));
    memset(low, 0, sizeof(int) * (n + 3));
    memset(f, 0, sizeof(int) * (n + 3));
    f[1] = 1, low[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            primes.push_back(i);
            low[i] = i;
            minp[i] = i;
            f[i] = getf(i, i);
        }
        for (const auto& pj : primes) {
            if (pj > n / i) break;

            int tgt = pj * i;
            minp[tgt] = pj;
            if (pj != minp[i]) {
                low[tgt] = pj;
                f[tgt] = f[pj] * f[i];
            }
            else {
                low[tgt] = pj * low[i];
                if (i == low[i]) {
                    f[tgt] = getf(pj, low[tgt]);
                }
                else {
                    f[tgt] = f[tgt / low[tgt]] * f[low[tgt]];
                }
                break;
            }
        }
    }
}
```

### 预处理后快速分解质因数
在预处理出`minp`数组后, 可以在$O(\log n)$的时间内完成质因数的单次询问. 不断除以`minp[i]`即可.

```cpp
vector<int> getfac(int x) {
    vector<int> ans;
    while (x > 1) {
        ans.push_back(minp[x]);
        x /= minp[x];
    }
    return ans;
}
```

## 整除分块(数论分块)
在$O(1)$得到$f_{pre}$和$g$的前提下, 以$O(\sqrt{n})$的复杂度计算$\displaystyle\sum_{i=1}^{limit}f(i)g(\lfloor \frac{n}{i}\rfloor)$.
```cpp
template <typename F>
void block_floor(ll N, F f) {
    ll sq = sqrtl(N);
    ll n = (sq * sq + sq <= N ? sq : sq - 1);
    for (ll l = 1; l <= sq; ++l) {
        f(N / l, l, l + 1); 
    }
    for (ll q = n; q >= 1; --q) {
        f(q, N / (q + 1) + 1, N / q + 1); 
    }
}
```

## 狄利克雷卷积
数论函数$f(n)$与$g(n)$的狄利克雷卷积记作$f*g$, 定义为$\displaystyle\sum_{k|n}f(k)g(\frac{n}{k}) = \sum_{kl=n}f(k)g(l)$.

:::note[常见的狄利克雷卷积]
1. 单位函数$\varepsilon$是默比乌斯函数$\mu$和常数函数$1$的狄利克雷卷积(莫比乌斯反演的核心):$$\varepsilon = \mu * 1 \iff \varepsilon(n) = \displaystyle\sum_{d|n}\mu(d)$$
2. 除数函数$d$是常数函数$1$和$1$的狄利克雷卷积:$$d(n) = \displaystyle\sum_{d|n}1$$
3. 除数和函数$\sigma$是恒等函数$id$和$1$的狄利克雷卷积:$$\sigma(n) = \displaystyle\sum_{d|n}d$$.
4. 欧拉函数$\varphi$是恒等函数$id$和莫比乌斯函数$\mu$的狄利克雷卷积:$$\varphi(n) = \displaystyle\sum_{d|n}d\mu(\frac{n}{d})$$
5. gcd和函数$P(n) = \displaystyle\sum_{i=1}^ngcd(i, n)$是恒等函数$id$与欧拉函数$\varphi$的狄利克雷卷积(所谓欧拉反演的核心).
:::

:::note[狄利克雷卷积的性质]
1. 交换律
2. 结合律
3. 对加法的分配律
4. 存在单位元, 为单位函数$\varepsilon$
5. 在$f(1)\ne 0$时存在逆元, 称为狄利克雷逆元. 逆元满足递推公式$$\displaystyle g(n) = \frac{\varepsilon(n) - \sum_{kl = n, k \ne 1}f(k)g(l)}{f(1)}$$
:::

如上性质表明全体数论函数在加法运算和狄利克雷卷积运算下构成**交换环**, 称为**狄利克雷环**.

## 莫比乌斯反演
由狄利克雷卷积可以知道$\mu * 1 = \varepsilon$, 即在狄利克雷环上, $\mu$与$1$互为逆元. 我们可以利用这个性质得到: 若$F = f * 1$, 则$f = F * \mu$. 更加正式地: 
$$\text{若}\displaystyle F(n) = \sum_{d|n}f(d), \text{则}f(n) = \sum_{d|n}\mu(d)F(\frac{n}{d})$$.

这个过程称作**莫比乌斯反演**. 这提醒我们: 对于某些函数$f(n)$, 如果我们很难直接求出它的值, 但却容易求出其倍数和或约数和$g(n)$的值, 那么我们可以通过莫比乌斯反演简化运算, 从而求得$f(n)$的值.