---
title: 竞赛算法(4) 数论
published: 2025-11-24
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---

## 数论函数
正整数到正整数的函数. 可以被看作一个数列.

### 积性函数
1. $f(1) = 1$.
2. 对于互质的$x$, $y$, 有$f(xy) = f(x)f(y)$.

:::note[完全积性函数]
1. $f(1) = 1$.
2. 对于任意的$x$与$y$, 有$f(xy) = f(x)f(y)$.
:::

:::note[积性函数的性质]
若$f(x), g(x)$都是积性函数:
1. $f(x^p)$也是积性函数.
2. $f^p(x)$也是积性函数.
3. $f(x)g(x)$也是积性函数.
4. $\displaystyle \sum _{d|x}f(d)g(\frac{x}{d})$也是积性函数.
5. 容易注意到正整数在唯一分解后, 积性函数等于其每一个质因数幂次的函数值相乘, 完全积性函数还等于其每一个质因数的函数值相乘.
:::

:::note[常见的积性函数]
1. 单位函数$\epsilon (n) = [n = 1].$即$n = 1$的指示函数. 为完全积性函数.
2. 恒等函数$id_k(n) = n^k, id(n) = n$. 完全积性.
3. 常数函数$1(n) = 1$. 完全积性.
4. 除数函数$\displaystyle \sigma _k(n) = \sum _{d|n}d^k$. 其中$\sigma _0(n)$常记作$d(n)$或$\tau(n)$, $\sigma_1(n)$常记作$\sigma(n)$.
5. 欧拉函数$\varphi(n) = \displaystyle\sum_{i = 1}^{n}[gcd(i, n) = 1]$.
6. 莫比乌斯函数$\mu (n)$. $n$为$1$时值为$1$, $n$为完全平方数的整数倍时值为$0$, 其他时候值为$(-1)^k$, 其中$k$为$n$的不相等质因子个数.
:::


## 欧拉函数
一种数论函数, 记作$\varphi(n)$, 是一种积性函数, 其含义为小于等于n的正整数中与n互质的数的个数.

:::note[欧拉函数的性质]
1. 欧拉函数是积性函数. 特别地, 当$n$为奇数时, $\varphi(2n) = \varphi(n)$.
2. $n = \displaystyle\sum_{d|n}\varphi(d)$. 即恒等函数$id$是常数函数$1$和欧拉函数$\varphi$的狄利克雷卷积.
3. 若$n = p^k$, 则$\varphi(n) = p^k - p^{k - 1}$.
4. $\varphi(n)$等于$n$除以所有不同的质因数, 再乘以所有不同质因数-1的结果.
:::

## 莫比乌斯函数
一种数论函数, 记作$\mu(n)$:
1. $n = 1$时$\mu(n) = 1$.
2. $n$的质因数分解形如$p_1p_2p_3\cdots p_k$, 其中$p_i$之间互不相等时, $\mu(n) = (-1)^k$.
3. 其他时候, $\mu(n) = 0$.

莫比乌斯函数是一种积性函数.

莫比乌斯函数可以使用质因数分解在$O(\sqrt{n})$时间内求出. 也可使用线性筛在$O(n)$时间内预处理出$1\sim n$内所有的莫比乌斯函数值.

## 欧拉筛
一种$O(n)$的筛法, 也叫线性筛.

:::[欧拉筛处理质数的过程]
1. 维护质数表`primes`(要求支持$O(1)$尾插), 最小质因数表`minp`.
2. 循环, 到`i`时(先判后筛):
   1. 判: 若`minp[i] == 0`, 说明没被筛过, 为质数. `minp[i] = i`, `primes`尾插`i`.
   2. 筛: 遍历所有小于等于`minp[i]`的质数`pj`. 我们考虑`i * pj`, 可以知道`pj`一定是`i * pj`的最小质因数(由唯一分解定理). 于是记录`minp[i * pj] = pj`, 表示`i * pj`已经被筛过.
:::

这个过程中, `minp`可以换成一个`bool`数组`vis`以节省空间, 这样的话筛的时候条件改为"从小到大遍历所有`i % pj != 0`的质数和第一个`i % pj == 0`的质数". 常数时间接近, 空间节省, 但缺少了副产物`minp`表.

欧拉筛可以用于预处理$\varphi(n)$和$\mu(n)$等. 利用其性质可以避开处理一般积性函数时较差的时空复杂度.

```cpp
// 全局
int minp[N];
// int phi[N], mu[N];

// 局部
vector<int> primes;
auto euler = [&](int n) -> void {
    primes.clear();
    memset(minp, 0, sizeof(int) * (n + 5));
    /*
    memset(phi, 0, sizeof(int) * (n + 5));
    memset(mu, 0, sizeof(int) * (n + 5));
    phi[1] = mu[1] = 1;
    */
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            primes.push_back(i);
            minp[i] = i;
            /*
            phi[i] = i - 1;
            mu[i] = -1;
            */
        }
        for (const auto& pj : primes) {
            if (pj > minp[i] || pj > n / i) break;
            /*
            if (pj == minp[i]) {
                phi[i * pj] = phi[i] * pj;
                mu[i * pj] = 0;
            }
            else {
                phi[i * pj] = phi[i] * (pj - 1);
                mu[i * pj] = -mu[i];
            }
            */
            minp[i * pj] = pj;
        }
    }
};
```

### 欧拉筛求一般积性函数
若可以在关于$k$的低次多项式时间(在算法竞赛中, 可以忽略"低次", 因为$k$可以看作常数)内得到积性函数$f$在$p^k$处的值(其中$p$为质数), 便可在$O(n)$内使用线性筛预处理出$1\sim n$范围内所有的$f(n)$值.

:::note[欧拉筛预处理积性函数的过程]
1. 维护质数表`primes`($O(1)$尾插). `<int>minp`或`<bool>vis`用于标记. `low`用于记录`i`的最小质因子的完整幂. `f`用于储存答案. 定义函数`getf(int p, int pk)`用于快速求$f(p^k)$. 初始化`f[1] = 1, low[1] = 1`.
2. 循环, 到`i`时(先判后筛):
   1. 判: 若为质数, 更新4项(包括`primes`).
   2. 筛, 其实就是3个分支, (注意`pj > n / i`时要提前`break`):
      1. `pj < minp[i]`, 更新3项.
      2. `pj == minp[i]`, 更新`low[tgt]`和`minp[tgt]`, 判断, 最后`break`:
         1. `i == low[i]`, 说明`i`是质数整幂, 调用`getf`;
         2. `i != low[i]`, 直接计算`f`.
:::

```cpp
// 全局
int minp[N], low[N];
ll f[N];

// 局部
vector<int> primes;
auto euler = [&](int n) -> void {
    primes.clear();
    memset(minp, 0, sizeof(int) * (n + 5));
    memset(low, 0, sizeof(int) * (n + 5));
    memset(f, 0, sizeof(int) * (n + 5));
    f[1] = 1, low[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            primes.push_back(i);
            low[i] = i;
            minp[i] = i;
            f[i] = getf(i, i);
        }
        for (const auto& pj : primes) {
            if (pj > n / i) break;

            int tgt = pj * i;
            minp[tgt] = pj;
            if (pj != minp[i]) {
                low[tgt] = pj;
                f[tgt] = f[pj] * f[i];
            }
            else {
                low[tgt] = pj * low[i];
                if (i == low[i]) {
                    f[tgt] = getf(pj, low[tgt]);
                }
                else {
                    f[tgt] = f[tgt / low[tgt]] * f[low[tgt]];
                }
                break;
            }
        }
    }
}
```

## 整除分块(数论分块)
在$O(1)$得到$f_{pre}$和$g$的前提下, 以$O(\sqrt{n})$的复杂度计算$\displaystyle\sum_{i=1}^{limit}f(i)g(\lfloor \frac{n}{i}\rfloor)$.
```cpp
// 要求 limit <= n
for (ll l = 1, r; l <= limit; l = r + 1) {
    // fpre(x) 为 f(x)的前缀和函数.
    ll q = n / l;  // 先得到 n / i 向下取整.
    r = n / q;
    r = min(r, limit);  // 再得到 q 这个值对应的 i 范围, 为 [l, r]
    sum += 1LL * (fpre(r) - fpre(l - 1)) * g(q);
}
```

## 狄利克雷卷积
数论函数$f(n)$与$g(n)$的狄利克雷卷积记作$f*g$, 定义为$\displaystyle\sum_{k|n}f(k)g(\frac{n}{k}) = \sum_{kl=n}f(k)g(l)$.

:::note[常见的狄利克雷卷积]
1. 单位函数$\varepsilon$是默比乌斯函数$\mu$和常数函数$1$的狄利克雷卷积(莫比乌斯反演的核心):$$\varepsilon = \mu * 1 \iff \varepsilon(n) = \displaystyle\sum_{d|n}\mu(d)$$
2. 除数函数$d$是常数函数$1$和$1$的狄利克雷卷积:$$d(n) = \displaystyle\sum_{d|n}1$$
3. 除数和函数$\sigma$是恒等函数$id$和$1$的狄利克雷卷积:$$\sigma(n) = \displaystyle\sum_{d|n}d$$.
4. 欧拉函数$\varphi$是恒等函数$id$和莫比乌斯函数$\mu$的狄利克雷卷积:$$\varphi(n) = \displaystyle\sum_{d|n}d\mu(\frac{n}{d})$$
5. gcd和函数$P(n) = \displaystyle\sum_{i=1}^ngcd(i, n)$是恒等函数$id$与欧拉函数$\varphi$的狄利克雷卷积(所谓欧拉反演的核心).
:::

:::note[狄利克雷卷积的性质]
1. 交换律
2. 结合律
3. 对加法的分配律
4. 存在单位元, 为单位函数$\varepsilon$
5. 在$f(1)\ne 0$时存在逆元, 称为狄利克雷逆元. 逆元满足递推公式$$\displaystyle g(n) = \frac{\varepsilon(n) - \sum_{kl = n, k \ne 1}f(k)g(l)}{f(1)}$$
:::

如上性质表明全体数论函数在加法运算和狄利克雷卷积运算下构成**交换环**, 称为**狄利克雷环**.

## 莫比乌斯反演
由狄利克雷卷积可以知道$\mu * 1 = \varepsilon$, 即在狄利克雷环上, $\varepsilon$与$1$互为逆元. 我们可以利用这个性质得到: 若$F = f * 1$, 则$f = F * \mu$. 更加正式地: 
$$\text{若}\displaystyle F(n) = \sum_{d|n}f(d), \text{则}f(n) = \sum_{d|n}\mu(d)F(\frac{n}{d})$$.

这个过程称作**莫比乌斯反演**. 这提醒我们: 对于某些函数$f(n)$, 如果我们很难直接求出它的值, 但却容易求出其倍数和或约数和$g(n)$的值, 那么我们可以通过莫比乌斯反演简化运算, 从而求得$f(n)$的值.