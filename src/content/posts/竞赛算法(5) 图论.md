---
title: 竞赛算法(5) 图论
published: 2025-11-26
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---
## 建图
### 邻接表
```cpp
struct Edge {
    int to;
    int w;
};
// 带权图
vector<Edge> adj[N];
inline void buildgraph(int n) {
    for (int i = 0; i <= n; i++) adj[i].clear();
}
```

## 遍历图
### DFS
```cpp
// vector<Edge> adj[N];
auto dfs = [&](int s) {
    stack<int> st;
    vector<bool> vis(n + 1, 0);
    st.push(s);
    while (!st.empty()) {
        int x = st.top();
        st.pop();
        if (vis[x]) continue;
        vis[x] = 1;
        for (const auto& [y, dy] : adj[x]) {
            if (!vis[y]) st.push(y);
        }
    }
};
```
### BFS
```cpp
// vector<Edge> adj[N];
auto bfs = [&](int s) {
    queue<int> q;
    vector<bool> vis(n + 1, 0);
    q.push(s);
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (const auto& [y, dy] : adj[x]) {
            if (!vis[y]) {
                q.push(y);
                vis[y] = 1;
            }
        }
    }
};
```

## 最短路问题
### 单源最短路
#### 正权图dijkstra
```cpp
// const ll INFLL = 1e18;
// using ll = long long;
// vector<Edge> adj[N];
// vector<ll> dis;

auto dijkstra = [&](int s = 1) -> void {
    dis.assign(n + 1, INFLL);
    using pli = pair<ll, int>;
    priority_queue<pli, vector<pli>, greater<pli>> q;
    q.emplace(0, s);
    dis[s] = 0;
    while (!q.empty()) {
        auto [dx, x] = q.top();
        q.pop();
        if (dx > dis[x]) continue;
        for (const auto& [y, dy] : adj[x]) {
            if (dis[x] + dy < dis[y]) {
                dis[y] = dis[x] + dy;
                q.emplace(dis[y], y);
            }
        }
    }
};
```