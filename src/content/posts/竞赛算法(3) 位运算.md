---
title: 竞赛算法(3) 位运算
published: 2025-11-24
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---
简单的跳过, 从典型trick开始.

## lowbit
```cpp
inline int lowbit(int n) {
    return x & (-x);
}
```

## 分类求缺失数
数组中只有2种数出现次数为奇数, 其他数出现次数均为偶数, 找到出现次数为奇数的数.

1. 设这两个数为a和b.
2. 取异或和sum, 则显然sum = a ^ b.
3. sum中至少存在一个1, 我们取任意一个1. 这里方便起见取一定存在的lowbit(sum).
4. lowbit(sum)一定由0和1异或而成, 所以a和b在lowbit(sum)这位上必然一个为0一个为1.
5. 我们将所有数分类成lowbit(sum)位上为0的数组arr0和为1的数组arr1, 则arr0中只有一个出现奇数次的数, arr1中只有一个出现奇数次的数. 问题转化为在数组中寻找唯一的出现次数为奇数的数. 取异或和即可.

## 判断2的整幂
```cpp
bool is2pow(int n) {
    return n > 0 && (n == lowbit(n));
}

// 更快的写法
bool is2powq(int n) {
    return n > 0 && __builtin_popcount(n) == 1;
}
```

## 判断n的整幂
```cpp
bool is3pow(int n) {
    return n > 0 && (1162261467 % n == 0); 
    // 其中1162261467是int范围内最大的3的整数次幂. 其它数字同理.
}
```

## 将最高位后的所有位填充为1
```cpp
inline bool fillbit(int n) {
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n;
}
// 应用: highbit
int highbit(int n) {
    return fillbit(n) - (fillbit(n) >> 1);
}

// 应用: 找到大于等于n的最小2整幂
int find2powgt(int n) {
    return fillbit(n - 1) + 1;
}
```

## 求[l, r]所有数字按位与的结果
```cpp
int andsum(int l, int r) {
    // [l, r]
    while (r > l) {
        r -= lowbit(r);
    }
    return r;
}
```

## 二进制低位与高位翻转
神人代码, 但很快. 状压中可能会用上.
```cpp
inline u32 bitrvs(u32 n) {
    n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
    n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
    n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
    n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
    n = (n >> 16) | (n << 16);
    return n;
}
```

## 二进制中1的数目
```cpp
// 直接使用内置函数
int __builtin_popcount(unsigned int x);
int __builtin_popcountl(unsigned long x);
int __builtin_popcountll(unsigned long long x);
// 注意参数类型(虽然会自动转换).
```

## 数据结构: bitset
也叫位图, 相当于超长二进制整数, 状压中有用. 除了std::bitset外还可以手写bitset, 好处是可以实现leftshift等操作.

一般应具有以下操作.
```cpp
inline int div64(int n) {
    return n >> 6;
}
inline int mul64(int n) {
    return n << 6;
}
u64 bs[div64(N) + 1];
void initbitset(int n);
void set(int p);
void clear(int p);
void flip(int p);
bool check(int p);  // 查询p位的状态.

// 扩展操作
void setall();
void clearall();
void flipall();
void allset();
void allclear();
int popcnt();
void leftshift();
void rightshift();
void biand(bs a, bs b);    // 需要先封装
void bior(bs a, bs b);
void bixor(bs a, bs b);
```
